# 똑장-오프라인파트-상세기획서

## 1. 문서 메타

| 항목 | 내용 |
|---|---|
| 문서명 | 똑장 오프라인 파트 상세 기획서 |
| 버전 | v1.3 |
| 작성일 | 2026-02-14 |
| 기준 문서 | `똑장아이디어기획안.ipynb` |
| 작성 관점 | 오프라인 담당 개발자 실행 스펙(백엔드 중심) |
| 대상 독자 | 오프라인 담당(본인), 팀원1(온라인), 팀원2(외부 API/확장), QA |
| 목표 | MVP 통합 시 오프라인 기능을 독립적으로 구현/검증/운영 가능하게 한다 |

### 문서 목적
- 오프라인 도메인의 요구사항을 구현 가능한 수준으로 고정한다.
- 팀 간 인터페이스 계약을 명확히 해서 병렬 개발 중 재작업을 줄인다.
- 개발 리스크와 운영 리스크를 사전에 통제한다.

### 성공 기준(오프라인 파트)
- 5개 품목 기준 오프라인 Top3 플랜 생성 성공률 99% 이상(테스트 환경).
- `POST /v1/offline/plans/generate` p95 응답시간 2.5초 이내(외부 API 정상 전제).
- 사용자 노출 가격 정보는 `가격/출처/갱신시점/주의문구` 규칙 준수(금지 필드 0건).

---

## 2. 역할 재정의 및 책임 경계(RACI)

### 2.1 팀 역할(신규 3분할)
- 오프라인(본인): 오프라인 가격/매장/이동/날씨 결합 로직, 오프라인 플랜 API, 오프라인 데이터 파이프라인.
- 온라인(팀원1): 온라인 후보 수집/정렬/링크 연동, 온라인 플랜 생성.
- 외부 API·확장(팀원2): Place/Routing/Weather/확장 API 안정화, API 키/쿼터/장애 정책.

### 2.2 RACI 매트릭스

| 업무 | 오프라인(본인) | 온라인(팀원1) | 외부 API/확장(팀원2) |
|---|---|---|---|
| 오프라인 플랜 API 구현 | A/R | I | C |
| 참가격/Mock 적재 파이프라인 | A/R | I | C |
| 매장 후보/이동시간/날씨 인터페이스 소비 | A/R | I | C |
| Place/Routing/Weather API 안정화 | C | I | A/R |
| 공통 Plan DTO 계약 | C | C | C |
| 랭킹/정책 회귀 테스트 | A/R | C | C |
| 운영 대시보드/알림 규칙 | A/R | C | C |

### 2.3 11개 페르소나 합의 결과(적용 의사결정)

| 페르소나 | 핵심 결정 | 적용 섹션 |
|---|---|---|
| PM/Planner | 목표를 결제 자동화가 아닌 의사결정 시간 단축으로 고정 | 1, 3, 13 |
| 시스템 아키텍트 | Provider 분리/의존 역전/캐시 계층 고정 | 4, 5, 10 |
| 오프라인 도메인 엔지니어 | 후보 필터 선적용 후 총액 계산/Top3 생성 | 7 |
| 온라인 도메인 엔지니어 | 공통 Plan DTO 정합성만 계약, 온라인 구현은 소유 제외 | 5, 15 |
| QA/테스트 엔지니어 | 계약·회귀·성능 테스트를 출시 게이트로 설정 | 12 |
| Critic/Reviewer | 과장 용어 금지, 실패모드/가정 명시 의무 | 5, 11, 14 |
| 데이터 큐레이터 | 참가격/Mock 스키마 표준화, 적재 무결성 규칙 고정 | 6 |
| 대화 UX/클래리파이어 | 브랜드/용량 질문 트리, 질문 횟수 상한 고정 | 8 |
| 비용/성능 | p95, 캐시 TTL, API 호출 예산 명시 | 10 |
| 컴플라이언스 | 스크래핑 금지, 최소 수집/보관 정책 강제 | 14 |
| Evals 엔지니어 | 품질 지표와 정기 평가 파이프라인 운영 | 13 |

---

## 3. 오프라인 MVP 범위 정의(in/out)

### 3.1 In Scope
- 오프라인 플랜 생성 API(`POST /v1/offline/plans/generate`) 구현.
- 오프라인 데이터 적재(참가격/Mock) 및 스냅샷 관리.
- 매장 후보 조회/이동시간 추정/날씨 주의 결합(팀2 API를 계약 기반 소비).
- 가격 매칭, 커버리지 계산, Top3 플랜 생성(최저가/가까움/균형).
- 사용자 노출 정보: `총액, 커버리지, 이동시간/거리, 날씨 주의, 가격 출처, 갱신시점, 주의문구`.

### 3.2 Out of Scope
- 온라인 결제 자동화, 온라인 API 구현, 파트너 정산.
- 트렌드 추천 모델 고도화.
- 외부 API 안정화 자체(팀2 소유).
- 사용자 장기 개인화 추천.

### 3.3 고정 가정
- MVP 전체(오프라인+온라인+외부 API)는 통합 완료를 목표로 한다.
- 외부 API 문제 해결은 팀2 소유이며, 오프라인은 안정된 계약을 소비하는 구현을 담당한다.
- 사용자 UI에는 `가격 정확도` 개념을 노출하지 않는다.

---

## 4. 시스템 아키텍처(오프라인 중심)

### 4.1 계층 구조
- `domain`: 순수 규칙(랭킹/필터/가격 계산/질문 정책).
- `application`: 유즈케이스 오케스트레이션(플랜 생성 파이프라인).
- `infrastructure/providers`: 외부 API 어댑터(Place/Routing/Weather/OfflinePrice).
- `infrastructure/persistence`: DB/캐시 저장소.
- `api`: 요청 검증, 응답 포맷, 에러 매핑.

### 4.2 오프라인 플랜 생성 시퀀스
1. 요청 수신 및 입력 검증.
2. 품목 정규화 및 질의 필요 여부 판정.
3. Place Provider(네이버 Local 검색 API)로 매장 후보 조회.
4. Routing Provider로 이동시간 계산.
   - `car`: 네이버 Directions API(자동차 경로 distance/duration).
   - `transit`: 네이버 Local API 거리 결과 + 대중교통 보정계수(×1.8) 적용. 추후 ODsay 전환 가능.
   - `walk`: 직선거리 × 1.3(도보 우회 보정) / 평균 보행속도 4km/h로 추정. 별도 도보 API 확보 시 어댑터 교체.
5. 사용자 허용 이동시간 필터 적용.
6. 가격 스냅샷 매칭 및 매장별 총액/커버리지 계산.
7. Weather Provider(기상청 단기예보 API)로 주의정보 결합.
8. Top3 플랜(최저가/가까움/균형) 생성.
9. 실행 로그 저장 및 응답 반환.

### 4.3 외부 API 구현체 매핑(MVP 확정)

| Provider | MVP 구현체 | API 문서 |
|---|---|---|
| Place | 네이버 Local 검색 API | https://developers.naver.com/docs/serviceapi/search/local/local.md |
| Routing(차량) | 네이버 Directions 5 API | https://api.ncloud-docs.com/docs/ai-naver-mapsdirections |
| Routing(도보) | 직선거리 보정 추정(자체 계산) | - |
| Routing(대중교통) | 네이버 Local 거리 + 보정계수(MVP), ODsay(추후) | https://lab.odsay.com/guide/guide |
| Weather | 기상청 단기예보 API | https://www.data.go.kr/data/15084084/openapi.do |
| OfflinePrice | 참가격 공공데이터 / Mock | https://www.data.go.kr/data/3043385/openapi.do |

> 네이버 API 키는 팀원2가 발급 완료. Client ID/Secret은 환경변수로 주입.

### 4.4 의존 역전 원칙
- 오프라인 유즈케이스는 인터페이스에만 의존한다.
- 실제 공급자(네이버/기상청/Mock)는 어댑터에서 교체 가능해야 한다.
- 공급자 장애 시 fallback(캐시/마지막 성공값) 정책을 기본으로 둔다.

---

## 5. 공개 API/내부 인터페이스/타입 계약

### 5.1 공개 API

#### `POST /v1/offline/plans/generate`

요청:
```json
{
  "user_context": {
    "lat": 37.5,
    "lng": 127.0,
    "travel_mode": "walk|transit|car",
    "max_travel_minutes": 25
  },
  "basket_items": [
    {
      "item_name": "두부",
      "brand": "풀무원",
      "size": "300g",
      "quantity": 2
    }
  ]
}
```

응답:
```json
{
  "plans": [
    {
      "plan_type": "lowest|nearest|balanced",
      "store_id": "S001",
      "store_name": "OO마트",
      "store_address": "서울특별시 강남구 테헤란로 123",
      "total_price_won": 15200,
      "coverage_ratio": 0.92,
      "recommendation_reason": "전체 장바구니 기준 최저가입니다. 지하 주차장이 있어 비를 피할 수 있으며, 모든 품목 재고가 있습니다.",
      "matched_items": [
        {
          "item_name": "두부",
          "brand": "풀무원",
          "size_display": "300g",
          "quantity": 2,
          "unit_price_won": 1500,
          "subtotal_won": 3000,
          "item_tag": "최저가|가성비|AI추천|null",
          "price_verified_at": "2026-02-14T09:55:00+09:00"
        }
      ],
      "missing_items": [
        {
          "item_name": "물티슈",
          "reason": "재고 없음|판매처 없음",
          "alternative": {
            "item_name": "순수 물티슈 캡형",
            "brand": "순수",
            "unit_price_won": 3200,
            "saving_won": 500,
            "tag": "성분 유사·가격 저렴"
          }
        }
      ],
      "assumptions": [
        {
          "item_name": "진라면",
          "field": "size",
          "assumed_value": "5봉",
          "reason": "용량 미지정, 표준 규격 자동 선택"
        }
      ],
      "travel_minutes": 18,
      "distance_km": 2.1,
      "weather_note": "비 예보",
      "price_source": "참가격|mock|partner",
      "price_observed_at": "2026-02-14T00:00:00+09:00",
      "price_notice": "조사 시점 기준, 현장 가격과 차이 가능"
    }
  ],
  "meta": {
    "request_id": "uuid",
    "generated_at": "2026-02-14T10:00:00+09:00",
    "degraded_providers": []
  }
}
```

HTTP 코드:
- `200`: 정상 생성.
- `206`: 일부 외부 의존 fallback으로 부분 결과 생성.
- `400`: 입력 오류.
- `422`: 품목 해석 불가(질문 필요).
- `503`: 필수 의존 실패로 결과 생성 불가.

에러 응답 포맷(공통):
```json
{
  "error": {
    "code": "INVALID_BASKET_ITEM|ITEM_CLARIFICATION_NEEDED|PROVIDER_UNAVAILABLE|INTERNAL_ERROR",
    "message": "사람이 읽을 수 있는 에러 설명",
    "details": [
      {
        "field": "basket_items[0].item_name",
        "reason": "품목명 해석 불가, 재입력 필요"
      }
    ],
    "request_id": "uuid"
  }
}
```
- `422` 응답 시 `details`에 질문이 필요한 품목과 선택지를 포함한다.
- `503` 응답 시 `details`에 장애 Provider 이름과 예상 복구 정보를 포함한다.
- `206` 응답 시 `meta.degraded_providers`에 fallback된 Provider 목록을 포함한다(예: `["routing", "weather"]`). 프론트는 이 정보로 "일부 정보가 추정값입니다" 안내를 노출한다.

#### `POST /v1/offline/plans/select`

사용자가 오프라인 플랜을 선택했을 때 기록하는 API. UI의 "이 플랜 선택하기" 버튼에 대응.

요청:
```json
{
  "request_id": "uuid (generate 응답의 meta.request_id)",
  "selected_plan_type": "lowest|nearest|balanced",
  "store_id": "S001"
}
```

응답:
```json
{
  "status": "confirmed",
  "store_name": "이마트 강남점",
  "store_address": "서울특별시 강남구 테헤란로 123",
  "navigation_url": "nmap://route?dlat=37.5&dlng=127.0&dname=이마트강남점",
  "selected_at": "2026-02-14T10:05:00+09:00"
}
```

- `navigation_url`: 네이버 지도 앱 딥링크. 프론트에서 바로 길찾기 실행 가능.
- 선택 로그는 `offline_plan_execution_log`에 기록(피드백 학습용).

### 5.2 내부 인터페이스(팀2 제공, 오프라인 소비)
```python
class IPlaceProvider(Protocol):
    """MVP 구현체: NaverLocalPlaceProvider (네이버 Local 검색 API)"""
    def searchNearby(self, lat: float, lng: float, categories: list[str], radius: int) -> list["OfflineStore"]: ...

class IRoutingProvider(Protocol):
    """MVP 구현체: NaverRoutingProvider (car), WalkEstimateProvider (walk), TransitEstimateProvider (transit)"""
    def estimate(self, origin: tuple[float, float], destination: tuple[float, float], travel_mode: str) -> "RouteEstimate": ...

class IWeatherProvider(Protocol):
    """MVP 구현체: KmaWeatherProvider (기상청 단기예보 API)"""
    def getAdvisory(self, lat: float, lng: float, time_window: str) -> "WeatherAdvisory": ...
```

### 5.2.1 도보 이동시간 추정 규칙(walk)
- 정상 경로: `직선거리(m) × 1.3(도보 우회 보정계수) / 66.7(m/min, 4km/h 기준)` → 분 단위 반올림.
- 보정계수 1.3 근거: 도심 도보 경로는 직선 대비 평균 1.2~1.4배(MVP 중간값 채택).
- 추후 네이버/카카오 도보 길찾기 API 확보 시 `WalkEstimateProvider` 어댑터만 교체.

### 5.3 공통 도메인 타입(고정)
- `BasketItem`
- `OfflineStore`
- `OfflinePriceSnapshot`
- `OfflinePlan`
- `MatchedItem` (품목별 가격/태그/검증시각)
- `MissingItem` (미커버 품목 + 사유 + 대체품)
- `ItemAlternative` (대체품 추천 정보)
- `PlanAssumption` (자동 선택 근거)
- `RankingPolicyInput`

### 5.4 금지 필드/표현
- 금지 필드: `accuracy_score`, `price_accuracy`, `confidence_percent`
- 금지 UI 용어: `가격 정확도`
- 허용 표현: `가격`, `출처`, `갱신시점`, `주의문구`

---

## 6. 오프라인 데이터 모델(참가격/Mock) 및 적재 파이프라인

### 6.1 테이블 스키마

#### `store_master`
| 컬럼 | 타입 | 제약 |
|---|---|---|
| store_id | TEXT | PK |
| store_name | TEXT | NOT NULL |
| address | TEXT | NOT NULL |
| category | TEXT | NOT NULL |
| lat | REAL | NOT NULL |
| lng | REAL | NOT NULL |
| source | TEXT | NOT NULL |
| is_active | INTEGER | DEFAULT 1 |
| updated_at | DATETIME | NOT NULL |

> `address`: 사용자에게 매장 위치를 텍스트로 노출하기 위해 도로명 주소를 기본 저장. 네이버 Local API 응답의 `roadAddress` 필드를 사용.

#### `product_norm`
| 컬럼 | 타입 | 제약 |
|---|---|---|
| product_norm_key | TEXT | PK |
| normalized_name | TEXT | NOT NULL |
| brand | TEXT | NULL |
| size_value | REAL | NULL |
| size_unit | TEXT | NULL |
| size_display | TEXT | NULL |
| category | TEXT | NULL |
| aliases_json | TEXT | NULL |
| updated_at | DATETIME | NOT NULL |

> 단위 분리 규칙: `size` → `size_value`(숫자) + `size_unit`(g/ml/ea/pack 등) + `size_display`(원본 표기, 예: "300g", "30구").
> 정규화 예시: "300g" → `size_value=300, size_unit=g, size_display="300g"` / "30구" → `size_value=30, size_unit=ea, size_display="30구"`

#### `offline_price_snapshot`
| 컬럼 | 타입 | 제약 |
|---|---|---|
| price_snapshot_key | TEXT | PK |
| store_id | TEXT | FK(`store_master.store_id`) |
| product_norm_key | TEXT | FK(`product_norm.product_norm_key`) |
| price_won | INTEGER | CHECK(`price_won > 0`) |
| observed_at | DATETIME | NOT NULL |
| source | TEXT | NOT NULL |
| notice | TEXT | NOT NULL |
| created_at | DATETIME | NOT NULL |

#### `offline_plan_execution_log`
| 컬럼 | 타입 | 제약 |
|---|---|---|
| execution_id | TEXT | PK |
| request_id | TEXT | NOT NULL |
| item_count | INTEGER | NOT NULL |
| candidate_store_count | INTEGER | NOT NULL |
| filtered_store_count | INTEGER | NOT NULL |
| selected_plan_types | TEXT | NOT NULL |
| latency_ms | INTEGER | NOT NULL |
| degraded | INTEGER | DEFAULT 0 |
| created_at | DATETIME | NOT NULL |

#### `offline_provider_call_log`
| 컬럼 | 타입 | 제약 |
|---|---|---|
| call_id | TEXT | PK |
| provider_name | TEXT | NOT NULL |
| endpoint_key | TEXT | NOT NULL |
| status_code | INTEGER | NULL |
| latency_ms | INTEGER | NOT NULL |
| cache_hit | INTEGER | DEFAULT 0 |
| error_class | TEXT | NULL |
| created_at | DATETIME | NOT NULL |

### 6.2 키 정책
- `product_norm_key = normalized_name + "|" + brand + "|" + size_value + size_unit`
- `price_snapshot_key = store_id + "|" + product_norm_key + "|" + observed_date`

### 6.3 Mock 데이터 생성 전략(Sprint 0~1용)

MVP 초기에는 참가격 API 연동 전에 Mock 데이터로 코어 로직을 검증한다.

#### Mock 데이터 규모
- 매장: 20개 (대형마트 5, 중형슈퍼 8, 편의점 7)
- 품목: 80개 (신선식품 25, 가공식품 30, 생활용품 25)
- 가격 스냅샷: 매장×품목 중 70% 커버리지(약 1,120건). 모든 매장이 모든 품목을 갖진 않는 현실을 반영.

#### Mock 데이터 포맷
- JSON 파일(`mock/stores.json`, `mock/products.json`, `mock/prices.json`)로 관리.
- Sprint 0에서 생성, Git 추적 대상.

#### 지역 샘플
- 서울 강남역 반경(도심), 경기 수원역 반경(중소도시) 2개 지역 기준.
- 매장 좌표는 실제 위치 기반으로 설정(네이버 Local API 응답 참조).

#### 가격 생성 규칙
- 참가격 포털의 실제 가격 범위를 참고하여 현실적 분포 생성.
- 대형마트 < 중형슈퍼 < 편의점 순서로 평균 가격 차이를 두어 랭킹 로직 검증 가능하게 설계.
- `source="mock"`, `notice="테스트용 데이터, 실제 가격 아님"` 고정.

### 6.4 적재 파이프라인
1. 소스 수집(참가격 API 또는 Mock 파일).
2. 품목명 정규화 및 단위 표준화.
3. 음수/0원 제거, 중복 스냅샷 최신본 선택.
4. 무결성 검사 실패 항목은 `quarantine` 큐로 분리.
5. 스냅샷 upsert.
6. 적재 결과 메트릭 기록.

### 6.5 적재 주기와 장애 대응
- 기본 주기: 1일 1회(03:00 KST 배치).
- 실패 시: 마지막 성공 스냅샷 사용.
- 48시간 이상 신규 스냅샷 없으면 경고, 72시간 초과 시 장애 알림.

### 6.6 캐시 전략

#### 캐시 저장소
- SQLite `cache.db`(본 DB `app.db`와 물리적 분리, 아이디어 기획안 설계 의도 준수).
- 테이블: `cache_entries(cache_key TEXT PK, value_json TEXT, expires_at DATETIME, created_at DATETIME)`.

#### 캐시 키 구조
| 대상 | 키 패턴 | TTL |
|---|---|---|
| 매장 후보 | `place:{lat_3dp}:{lng_3dp}:{category}:{radius}` | 30분 |
| 차량 경로 | `route:car:{origin_lat}:{origin_lng}:{dest_lat}:{dest_lng}` | 10분 |
| 날씨 | `weather:{lat_2dp}:{lng_2dp}:{hour_block}` | 30분 |
| 가격 스냅샷 | DB 직접 조회(캐시 불필요, 배치 갱신) | - |

> 좌표 키에서 소수점 자릿수를 제한(3dp=약 110m 단위)하여 근접 요청을 같은 캐시로 처리.

#### 캐시 무효화 조건
- TTL 만료 시 자동 삭제(조회 시 lazy eviction).
- 외부 Provider 장애 복구 후 해당 Provider 캐시 일괄 무효화(stale 방지).
- 일 1회 03:30 KST에 만료된 캐시 일괄 정리(batch cleanup).

---

## 7. 핵심 유즈케이스 상세(입력→정규화→매장후보→가격매칭→플랜생성)

### 7.1 UC-01 오프라인 플랜 생성

입력:
- 사용자 위치/이동수단/최대 이동시간
- 장바구니 품목(브랜드/용량 optional)

처리:
1. `BasketItem` 정규화.
2. 매장 후보 검색.
3. 이동시간 계산 후 필터링(`travel_minutes <= max_travel_minutes`).
4. 가격 매칭 및 총액 계산. 품목별 `item_tag` 부여(최저가/가성비/AI추천).
5. 커버리지 계산(`matched_items / total_items`).
6. 미커버 품목에 대해 유사품 대체 추천 매칭(`missing_items[].alternative`).
7. 날씨 주의정보 결합.
8. 플랜 3종 생성 + 각 플랜별 `recommendation_reason` 생성.

출력:
- `lowest`, `nearest`, `balanced` 각 1개씩(가능한 범위 내).
- 각 플랜에 `price_source`, `price_observed_at`, `price_notice` 포함.

### 7.2 랭킹 정책(고정)
- `lowest`: `total_price_won ASC`, `coverage_ratio DESC`, `travel_minutes ASC`
- `nearest`: `travel_minutes ASC`, `total_price_won ASC`, `coverage_ratio DESC`
- `balanced`: 아래 점수 최소값 선택
  - `score = 0.5 * normalized_price + 0.3 * normalized_travel - 0.2 * normalized_coverage`
  - 가중치 근거: MVP 초기값이며, "가격 > 이동시간 > 커버리지" 우선순위를 반영. Evals 주간 평가(섹션 13) 결과에 따라 조정 예정.
  - 부호 확인: normalized 값은 0~1 정규화이며, score가 낮을수록 좋은 플랜. coverage는 높을수록 좋으므로 음수(-0.2)가 맞음.

### 7.3 커버리지 및 제외 규칙
- 커버리지 `< 0.6`이면 기본적으로 추천 제외.
- 단, 후보가 부족한 지역에서는 커버리지 0.4 이상을 보조안으로 노출 가능(플래그 기반).

### 7.4 Graceful Degradation
- Place 실패: 캐시된 후보 매장으로 대체, 없으면 `503`.
- Routing 실패: 직선거리 기반 추정시간 fallback 후 `degraded=true`.
- Weather 실패: `weather_note="정보 없음"` 처리.

### 7.5 사용자 노출 문구 정책
- 반드시 포함: `가격 출처`, `가격 갱신시점`, `주의문구`.
- 기본 주의문구 템플릿: `조사 시점 기준, 현장 가격과 차이 가능`.

---

## 8. 대화 UX/클래리파이어 정책(브랜드·용량 질문 정책)

### 8.1 질문 트리
1. 품목 인식 불명확: 품목명 재질문 1회.
2. 브랜드 미지정 + 가격편차 큰 경우: 브랜드 선택 질문.
3. 용량 미지정 + 규격 다중 존재: 용량 선택 질문.

### 8.2 질문 횟수 정책
- 품목당 최대 2회.
- 전체 세션 최대 8회.
- 초과 시 기본값 정책(추천 모드) 적용 후 계산 진행.

### 8.3 기본값 정책
- 브랜드 미지정: 상위 판매 브랜드 중 가격/커버리지 유리한 후보 사용.
- 용량 미지정: 표준 규격 우선(예: 두부 300g 계열).
- 모든 자동선택 결과는 응답에 `assumptions`로 명시.

### 8.4 질문 흐름과 API 관계
- 브랜드/용량 질문은 **LangGraph 대화 흐름 내에서 처리**된다(아이디어 기획안 페이지 3 "에이전트가 브랜드/용량을 물어봄" 준수).
- 대화 흐름: 사용자 입력 → `parse` 노드 → 질문 필요 판정 → `clarify` 노드(질문/응답) → 확정 후 `rank` 노드 → 플랜 생성.
- `POST /v1/offline/plans/generate`는 **확정된 BasketItem만 수신**한다. 질문이 필요한 상태에서는 이 API가 호출되지 않음.
- `422` 응답은 예외적으로 대화 흐름 외부에서 직접 API를 호출했을 때(예: 테스트/외부 연동)만 발생하는 안전장치.

### 8.5 실패/예외 처리
- 동일 품목 반복 오인식 2회 시 텍스트 입력 전환 가이드 표시.
- 단위 충돌(g/ml/개수) 감지 시 필수 확인 질문 우선.

---

## 9. 개발 단계 실행 계획(스프린트/작업 분해/완료 기준)

### 9.1 Sprint 0 (계약 고정 + Mock 준비, 2일)
- OpenAPI 초안 및 타입 계약 동결.
- 팀2 인터페이스 시그니처 확정.
- 금지 필드/표현 린트 룰 초안 적용.
- Mock 시드 데이터 생성(매장 20개, 품목 80개, 가격 스냅샷 ~1,120건). 섹션 6.3 기준.
- 에러 응답 포맷 공유 및 프론트 계약 확인.

완료 기준:
- `POST /v1/offline/plans/generate` 계약 리뷰 승인.
- 인터페이스 문서 서명 완료.
- Mock 데이터 파일 3종(`stores.json`, `products.json`, `prices.json`) Git 커밋.

### 9.2 Sprint 1 (오프라인 코어 루프, 5일)
- 데이터 스키마 및 저장소 구현.
- 가격 스냅샷 적재 배치(참가격/Mock).
- 후보 매장 필터 + 가격 매칭 + Top3 생성 구현.

완료 기준:
- 5개 품목 입력 시 오프라인 플랜 3개 재현.
- 단위/통합 테스트 통과율 90% 이상.

### 9.3 Sprint 2 (외부 의존 결합 및 품질, 5일)
- Place/Routing/Weather 어댑터 연결.
- fallback/캐시/재시도 정책 적용.
- 관측성/알림/운영 대시보드 구성.

완료 기준:
- p95 2.5초 이내.
- 장애 시 degraded 응답 정책 검증 완료.

### 9.4 Sprint 3 (안정화, 3일)
- 회귀 테스트 세트 고정.
- QA 시나리오 전수 통과.
- 운영 런북 드릴(모의 장애) 완료.

완료 기준:
- 릴리스 체크리스트 100% 충족.

---

## 10. 운영 단계 계획(모니터링, 비용, 장애 대응 런북)

### 10.1 SLO/SLA
- API 가용성: 99.0%/월.
- `generate` p95 지연: 2.5초 이하.
- 가격 스냅샷 최신성: 24시간 이내.

### 10.2 핵심 메트릭
- `offline_plan_generate_latency_ms` (p50/p95/p99)
- `offline_plan_generate_success_total`
- `offline_plan_generate_degraded_total`
- `offline_provider_call_total{provider,status}`
- `offline_cache_hit_ratio`
- `offline_price_snapshot_age_hours`

### 10.3 비용 예산(월 기준)
- Place/Routing/Weather API 호출 상한: 30만 콜.
- 초과 방지: 캐시 TTL(매장후보 30분, 경로 10분, 날씨 30분), 동일 요청 디듀프.
- 예산 80% 도달 시 경고, 95% 도달 시 저비용 모드(호출 축소) 전환.

### 10.4 장애 대응 런북
- P1: 전면 실패(503 급증)
  - 조치: 외부 Provider 회로차단기 활성화, 캐시 우선 응답.
- P2: 지연 급증(p95 초과)
  - 조치: 병목 Provider 확인, 타임아웃 하향, 동시성 제한.
- P3: 데이터 신선도 저하
  - 조치: 적재 잡 재실행, 마지막 성공 스냅샷 고정 공지.

---

## 11. 리스크 레지스터(개발/운영)

| ID | 구분 | 리스크 | 영향 | 가능성 | 대응 | 오너 |
|---|---|---|---|---|---|---|
| R-01 | 개발 | 팀 간 API 계약 불일치 | 높음 | 중간 | 계약 테스트/스키마 고정 | 오프라인 |
| R-02 | 개발 | 상품 정규화 충돌 | 중간 | 높음 | 정규화 룰 버전관리/예외사전 | 오프라인 |
| R-03 | 개발 | 좌표계/주소 변환 불일치 | 중간 | 중간 | 좌표 변환 유틸 단일화 | 팀2+오프라인 |
| R-04 | 개발 | 테스트 데이터 편향 | 중간 | 중간 | 도시/비도시 샘플 분리 | QA |
| R-05 | 운영 | 가격 갱신 지연 | 높음 | 중간 | 스냅샷 나이 경보/재적재 | 오프라인 |
| R-06 | 운영 | 외부 API 쿼터 초과 | 높음 | 중간 | 예산 알림/캐시/콜 제한 | 팀2 |
| R-07 | 운영 | Provider 장애 | 높음 | 중간 | fallback/회로차단기 | 오프라인+팀2 |
| R-08 | 운영 | 설명문구 오해 | 중간 | 낮음 | 문구 표준 템플릿/UX 검수 | PM+QA |
| R-09 | 정책 | 금지 필드 노출 | 높음 | 낮음 | 응답 검증기/리뷰 게이트 | 오프라인+QA |

---

## 12. QA 테스트 전략 및 케이스

### 12.1 테스트 전략
- 단위 테스트: 랭킹/커버리지/질문정책/정규화 규칙.
- 통합 테스트: DB + Provider Mock + API 계층.
- 계약 테스트: 팀2 인터페이스 스키마 호환성.
- 성능 테스트: 5품목×20매장 기준 p95 측정.
- 회귀 테스트: 정책 변경 시 결과 일관성 확인.

### 12.2 필수 시나리오(출시 게이트)

| TC ID | 시나리오 | 입력 조건 | 기대 결과 |
|---|---|---|---|
| TC-01 | 정상 5품목 | 일반 품목 5개 | 오프라인 플랜 3개 반환 |
| TC-02 | 브랜드 고정 미존재 | 특정 브랜드 없음 | 대체안 + 사유 노출 |
| TC-03 | 용량 미지정 | 다중 규격 존재 | 질문 정책 발동 후 재계산 |
| TC-04 | 이동 제한 | max_travel 10분 | 초과 매장 제외 |
| TC-05 | 데이터 누락 | 일부 품목 가격 없음 | coverage 하락 반영 |
| TC-06 | 외부 의존 장애 | place/routing/weather timeout | degraded 응답 또는 fallback |
| TC-07 | 캐시 검증 | 동일 요청 반복 | cache hit 증가/응답 개선 |
| TC-08 | 성능 | 5x20 부하 | p95 목표 이내 |
| TC-09 | 회귀 | 랭킹 규칙 변경 | 기준 결과 불변성 확인 |
| TC-10 | 컴플라이언스 | 응답 필드 검사 | `accuracy_*` 미노출 |

---

## 13. 품질 평가(Evals) 체계

### 13.1 평가 목적
- “실행 가능 결과” 품질을 주기적으로 수치화한다.
- 알고리즘/데이터/외부 의존 변화에 따른 품질 저하를 조기 탐지한다.

### 13.2 지표
- `Coverage@Top1`: Top1 플랜 품목 커버리지 평균.
- `PriceCompetitiveness`: 기준 바스켓 대비 절감률.
- `PlanAcceptanceProxy`: 테스트 사용자 선택률(Top1/Top3).
- `LatencyP95`: 응답시간.
- `DegradedRate`: fallback 응답 비율.

### 13.3 평가 데이터셋
- 고정 바스켓 100세트(신선식품/가공식품/생활용품 혼합).
- 지역 샘플 5종(도심/외곽/교통취약 포함).
- 브랜드 고정/미고정 케이스를 50:50으로 구성.

### 13.4 평가 주기
- 일간: 스모크 20세트 자동 실행.
- 주간: 전체 100세트 회귀 평가.
- 릴리스 전: 성능/정책/컴플라이언스 종합 평가.

### 13.5 품질 게이트
- `Coverage@Top1 >= 0.80`
- `LatencyP95 <= 2500ms`
- `DegradedRate <= 0.15`
- 컴플라이언스 위반 0건

---

## 14. 컴플라이언스/정책 체크리스트(약관·개인정보·스크래핑 금지)

### 14.1 데이터/수집 정책
- 스크래핑 금지: 공식/제휴 API만 사용.
- 개인정보 최소수집: 위치·바스켓 처리에 필요한 최소 필드만 저장.
- 원본 음성 저장 금지(옵트인 별도 합의 시에만 예외).

### 14.2 저장/보관 정책
- 위치 원본은 요청 처리 후 비식별 요약만 보관(필요 시 24시간).
- 실행 로그 보관 90일, 보안 로그 180일.
- 민감정보(토큰/API 키) 평문 저장 금지.

### 14.3 사용자 고지 정책
- 가격 정보는 조사 시점 기준이며 현장과 차이가 날 수 있음을 명시.
- 출처 및 갱신시점을 함께 표시.
- 추천 결과는 의사결정 보조 정보임을 명시.

### 14.4 점검 체크리스트
- [ ] 금지 필드(`accuracy_*`) 미노출
- [ ] `price_source`, `price_observed_at`, `price_notice` 포함
- [ ] 외부 API 이용약관 준수 확인
- [ ] 로그 비식별 처리 확인
- [ ] 데이터 보관기간 만료 삭제 잡 활성화

---

## 15. 부록(팀 인터페이스 SLA, 용어사전, 결정 로그)

### 15.1 팀 인터페이스 SLA

| 인터페이스 | 제공자 | 목표 응답시간(p95) | 가용성 | 오류 시 계약 |
|---|---|---|---|---|
| `IPlaceProvider.searchNearby` | 팀2 | 500ms | 99% | 캐시 후보 또는 빈 리스트 |
| `IRoutingProvider.estimate` | 팀2 | 700ms | 99% | 직선거리 fallback |
| `IWeatherProvider.getAdvisory` | 팀2 | 400ms | 99% | `정보 없음` 반환 |

### 15.2 용어사전
- 커버리지: 장바구니 품목 중 가격 매칭된 품목 비율.
- 스냅샷: 특정 시점의 매장-상품 가격 기록.
- Degraded 응답: 일부 의존 장애에도 fallback으로 반환된 결과.
- 균형 플랜: 가격/이동시간/커버리지를 가중치로 계산한 추천.

### 15.3 결정 로그

| 결정 ID | 날짜 | 내용 | 상태 |
|---|---|---|---|
| D-001 | 2026-02-14 | 역할 분담을 오프라인/온라인/외부 API로 재정의 | 확정 |
| D-002 | 2026-02-14 | 사용자 노출에서 `가격 정확도` 용어 제거 | 확정 |
| D-003 | 2026-02-14 | 외부 API 안정화는 팀2 소유, 오프라인은 계약 소비 구현 | 확정 |
| D-004 | 2026-02-14 | 오프라인 문서 범위를 백엔드 중심 실행 스펙으로 고정 | 확정 |
| D-005 | 2026-02-14 | 오프라인 핵심 API를 `POST /v1/offline/plans/generate`로 고정 | 확정 |
| D-006 | 2026-02-15 | Place/Routing API를 네이버 Local API로 확정(팀원2 키 발급 완료) | 확정 |
| D-007 | 2026-02-15 | 도보 이동시간은 직선거리×1.3/4km/h로 MVP 추정, 추후 API 교체 | 확정 |
| D-008 | 2026-02-15 | store_master에 address 컬럼 추가, product_norm에 size 3분할(value/unit/display) | 확정 |
| D-009 | 2026-02-15 | 캐시 저장소를 cache.db(SQLite)로 분리, 키/TTL/무효화 정책 고정 | 확정 |
| D-010 | 2026-02-15 | Mock 데이터 규모를 매장20/품목80/스냅샷~1120건으로 고정 | 확정 |
| D-011 | 2026-02-15 | 응답에 matched_items/missing_items/assumptions 필드 추가 | 확정 |
| D-012 | 2026-02-15 | 206 응답 시 meta.degraded_providers로 fallback Provider 노출 | 확정 |
| D-013 | 2026-02-15 | 브랜드/용량 질문은 LangGraph 대화 흐름 내 처리, API는 확정 입력만 수신 | 확정 |
| D-014 | 2026-02-15 | UI 디자인 14개 화면 참조 반영, 오프라인 핵심 화면 4개 API 매핑 완료 | 확정 |
| D-015 | 2026-02-15 | 응답에 recommendation_reason, item_tag, price_verified_at 필드 추가 | 확정 |
| D-016 | 2026-02-15 | missing_items를 문자열 배열→객체 배열로 확장(reason, alternative 포함) | 확정 |
| D-017 | 2026-02-15 | 플랜 선택 API `POST /v1/offline/plans/select` 신규 추가 | 확정 |
| D-018 | 2026-02-15 | 대체품 추천은 MVP 포함(단순 유사품 매칭), AI 소비분석/맞춤추천은 제외 | 확정 |

---

## 16. UI 화면 참조 및 API-UI 매핑

> 참조 디자인: `stitch_remix_of_smart_basket_input/` 폴더 (팀원 제공 UI 디자인 예시)

### 16.1 전체 화면 플로우(14개 화면)

```
[초기 설정] → [장바구니 입력] → [구매 방식 선택] → [분석 중] → [결과 화면] → [상세/선택] → [결제/완료]
```

| 순서 | 화면 | 폴더명 | 오프라인 관련도 |
|---|---|---|---|
| 1 | 쇼핑 환경 설정 (폼) | `shopping_preferences_setup` | **높음** - 위치/이동수단/최대이동시간 |
| 2 | 초기 설정 (대화형) | `대화형_환경_설정` | **높음** - 동일 정보를 대화로 수집 |
| 3 | 장바구니 담기 | `smart_basket_input` | **높음** - 브랜드 고정/추천 모드 토글 |
| 4 | 음성 입력 확인 | `음성_입력_확인_및_수정` | 중간 - STT 결과 확인/수정 |
| 5 | 구매 방식 선택 | `구매_방식_선택` | **높음** - 온라인/오프라인 분기점 |
| 6 | 분석 중 (로딩) | `analyzing_best_options` | **높음** - 4단계 진행 표시 |
| 7 | 오프라인 추천 플랜 | `offline_shopping_plans` | **핵심** - Top3 플랜 카드 |
| 8 | 온라인 추천 플랜 | `online_shopping_plans` | 낮음 - 온라인 담당 |
| 9 | 일부 품목 미검색 | `partial_match_results` | **높음** - 커버리지 시각화 |
| 10 | 상세 품목 및 가격 확인 | `상세_품목_및_가격_확인` | **핵심** - 품목별 가격/태그/대체품 |
| 11 | 장보기 상세 내역 | `상품별_상세_정보_및_대체_추천` | **핵심** - AI 대체 추천/절약 |
| 12 | 똑장 AI 채팅 모달 | `똑장_ai_채팅_모달` | 낮음 - 추천 기능(후순위) |
| 13 | 주문 결제 확인 | `온라인_주문_결제_확인` | 낮음 - 온라인 결제 |
| 14 | 결제 완료 | `주문_및_결제_완료` | 낮음 - 온라인 결제 |

### 16.2 오프라인 핵심 화면 → API 필드 매핑

#### 화면 7: 오프라인 추천 플랜 (`offline_shopping_plans`)

| UI 요소 | API 필드 | 비고 |
|---|---|---|
| "#1 최저가 추천" / "#2 최단 시간" 태그 | `plan_type` | lowest/nearest/balanced |
| "이마트 강남점" | `store_name` | |
| "2.4km 거리" | `distance_km` | |
| "이동 12분" | `travel_minutes` | |
| "45,200원" | `total_price_won` | |
| "커버리지 12/12 발견" | `coverage_ratio` + `matched_items` 길이 | |
| "날씨 주의: 비" 뱃지 | `weather_note` | |
| "왜 이 추천이 1등인가?" 설명 박스 | `recommendation_reason` | **v1.2 추가** |
| "출처: 조사 데이터" | `price_source` | |
| "업데이트: 2시간 전" | `price_observed_at` | 프론트에서 상대시간 변환 |
| "이 플랜 선택하기" 버튼 | `POST /v1/offline/plans/select` | **v1.3 추가** |

#### 화면 9: 일부 품목 미검색 (`partial_match_results`)

| UI 요소 | API 필드 | 비고 |
|---|---|---|
| "8/12 발견됨" 원형 차트 | `coverage_ratio` | 프론트에서 시각화 |
| "구매 가능 (8)" 썸네일 목록 | `matched_items` | |
| "미검색 품목 (4)" + 사유 | `missing_items[].reason` | "재고 없음", "판매처 없음" |

#### 화면 10: 상세 품목 및 가격 확인 (`상세_품목_및_가격_확인`)

| UI 요소 | API 필드 | 비고 |
|---|---|---|
| "B마트 알뜰 플랜" 헤더 | `store_name` + `plan_type` | |
| "9/10 품목" | `coverage_ratio` | |
| 품목별 가격/수량 | `matched_items[].unit_price_won`, `quantity` | |
| "최저가 추천" / "AI 추천" / "가성비" 태그 | `matched_items[].item_tag` | **v1.3 추가** |
| "실시간 재고 확인됨 · 5분 전" | `matched_items[].price_verified_at` | **v1.3 추가** |
| "미포함 품목" 섹션 | `missing_items` | |
| "대체품 찾기" 버튼 | `missing_items[].alternative` | **v1.3 추가** |
| "이 플랜으로 결정하기" 버튼 | `POST /v1/offline/plans/select` | |

#### 화면 11: 장보기 상세 내역 (`상품별_상세_정보_및_대체_추천`)

| UI 요소 | API 필드 | 비고 |
|---|---|---|
| "AI 대체 추천" 카드 | `missing_items[].alternative` | |
| "500원 절약" 표시 | `missing_items[].alternative.saving_won` | |
| "성분 유사 · 가격 저렴" 태그 | `missing_items[].alternative.tag` | |
| 원래가격 취소선 + 대체가격 | 원래 item의 예상가 vs alternative.unit_price_won | |
| 하단 면책 문구 | `price_notice` | |

### 16.3 UI에서 발견된 추가 기능(MVP 범위 판정)

| UI 기능 | MVP 포함 | 근거 |
|---|---|---|
| 추천 이유 설명 ("왜 1등인가?") | **포함** | 아이디어 기획안 "설명 가능한 추천" 핵심 가치 |
| 품목별 태그 (최저가/가성비/AI추천) | **포함** | 의사결정 보조에 필수 |
| 미커버 품목 대체품 추천 | **포함(단순)** | UI에 이미 반영, 가격 스냅샷 내 유사품 매칭으로 구현 |
| 플랜 선택 + 길찾기 연동 | **포함** | UI "이 플랜 선택하기" 버튼 존재, 네이버 지도 딥링크 |
| AI 소비 분석 팁 | **제외** | 결제 완료 화면(온라인), 개인화 데이터 축적 필요 |
| 맞춤형 추천 상품 | **제외** | 트렌드 추천 후순위(아이디어 기획안 토의 주제) |

### 16.4 analyzing_best_options 화면 → 처리 단계 매핑

UI 로딩 화면의 4단계는 오프라인 플랜 생성 시퀀스(섹션 4.2)와 대응:

| UI 단계 | 기획서 시퀀스 | 프론트 표시용 |
|---|---|---|
| 1. 장바구니 구조화 | 시퀀스 1~2 (입력 검증 + 정규화) | "12개 품목을 3개 카테고리로 정리 완료..." |
| 2. 온/오프라인 후보 수집 | 시퀀스 3~4 (Place + Routing) | "이마트, 홈플러스 스캔 중..." |
| 3. 이동 및 날씨 분석 | 시퀀스 5~7 (필터 + 가격매칭 + 날씨) | "위치 데이터 대기 중..." |
| 4. 최적의 플랜 랭킹 | 시퀀스 8~9 (Top3 생성 + 로그) | "최종 의사결정 엔진..." |

> 프론트에 처리 진행 상태를 보여주려면, 향후 SSE(Server-Sent Events) 또는 폴링 방식 검토 필요. MVP에서는 단일 요청/응답으로 처리하되, 예상 소요시간(~5초)을 프론트에서 프로그레스 바로 표현.

---

## 명시적 가정 및 기본값(재확인)
- 오프라인 파트 범위: 백엔드 중심.
- 문서 형태: 실행형 기술기획서.
- 팀2 외부 API가 정상 공급된다는 전제로 오프라인 구현 계획 수립.
- MVP 전체 기능은 3인 통합 구현을 전제.
- 사용자 신뢰 보호를 위해 `가격 정확도` 표현은 사용하지 않는다.

