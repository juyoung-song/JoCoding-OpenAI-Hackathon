---
trigger: always_on
---

# 똑장 프로젝트 규칙 (Rules)

## 프로젝트 개요

- **프로젝트명**: 똑장 (똑똑한 장보기)
- **목적**: 2030대를 위한 장보기 에이전트 서비스
- **핵심 가치**: 장바구니를 만들면 → 온라인/오프라인 후보를 찾아주고 → (가격 + 거리/시간/날씨) 정보를 붙여 → 사용자가 '납득 가능한 선택'을 하게 돕는다.

---

## 참고 자료

> **큰 작업을 시작하기 전에 반드시 `reference/` 디렉토리를 참고할 것**
> - `reference/ARCHITECTURE.md` — 백엔드/프론트엔드 디렉토리 구조 및 설계 원칙
> - `reference/stack.md` — 기술 스택 정보
> - `PRD.md` — 서비스 상세 기획서
> - `ui` - 페이지 단위 UI 설계

---

## 1. 아키텍처 원칙

### 1-1. 계층 분리
- **domain**: 순수 비즈니스 규칙만 담당 (외부 API 의존 없음)
- **application**: 유즈케이스/오케스트레이션 계층 (흐름 조합)
- **infrastructure**: 외부 의존성 격리 (Provider 패턴으로 교체 가능)
- **graph**: LangGraph 기반 대화 오케스트레이션 전담 (비즈니스 로직은 service 호출)
- **api**: HTTP 엔드포인트 계층 (얇게 유지)

### 1-2. Provider 패턴
- 모든 외부 API 연동은 Provider 인터페이스로 격리
- 데이터 소스가 바뀌어도 제품이 유지되는 구조 필수
- Provider 종류: `OnlineProvider`, `OfflineProvider`, `WeatherProvider`, `PlaceProvider`, `RoutingProvider`, `STTProvider`

### 1-3. DB 분리
- 본 DB와 캐시 DB는 물리적으로 분리 (SQLite 기준 `app.db` / `cache.db`)
- API 쿼터/호출 제한에 대비한 캐시 전략 필수

---

## 2. 기술 스택

### Backend
- **프레임워크**: FastAPI
- **AI 챗봇**: LangGraph 기반
- **DB**: SQLite (Dev) → PostgreSQL (Production)
- **캐시**: SQLite (Dev) → Redis (Production)
- **코드 스타일**: PEP 8

### Frontend
- **프레임워크**: React.js (웹 기반 PWA, 모바일 only)
- **코드 스타일**: Standard Style

### 외부 API
- **STT**: OpenAI Whisper (서버)
- **온라인 가격**: 네이버 쇼핑 검색 API
- **결제 Mock**: KakaoPay
- **장소 검색**: 네이버 Local API
- **경로/거리**: 네이버 Local API (차량), ODsay (대중교통)
- **날씨**: 기상청 단기예보 API

---

## 3. 코딩 규칙

### 3-1. 공통
- 한국어 주석 허용, 변수/함수명은 영문 사용
- 모든 API 엔드포인트는 OpenAPI 스펙 먼저 작성 → 구현
- 에러 처리는 도메인별 커스텀 예외 사용
- 환경 변수로 설정 관리 (API 키, DB 경로 등)

### 3-2. Backend (Python)
- PEP 8 준수
- Type hints 필수
- Pydantic 모델로 요청/응답 스키마 관리
- Provider는 인터페이스(ABC) 기반으로 구현
- 테스트: unit + integration 분리

### 3-3. Frontend (JavaScript/React)
- 컴포넌트는 feature 단위로 분리
- 상태 관리는 전역(providers/)과 로컬 분리
- 모바일 only 레이아웃 기준 설계

---

## 4. MVP 핵심 원칙

### 4-1. 반드시 구현할 6가지 기능
1. 장바구니 리스트 생성 (브랜드/용량 선호 포함)
2. 전체 품목 기준 최저가(총액 최소) 후보 찾기
3. 오프라인: 사용자 설정 거리/시간 내 후보 + 거리/시간/날씨 의사결정 보조
4. 온라인: 최소한 구매 링크/장바구니 이동 제공
5. 트렌드 추천: MVP에서는 추천 슬롯만 UI/데이터 구조 준비
6. 음성 입력 필수 (텍스트와 동등한 입력 채널)

### 4-2. MVP 금지 사항
- ❌ 웹 스크래핑 (약관/차단/유지보수 리스크)
- ❌ 자동 로그인 / 자동 장바구니 조작 / 자동 결제
- ❌ 원본 음성 저장 (opt-in 없이)
- ❌ 사용자 식별 정보 과도한 수집

### 4-3. 가격/신뢰도 정책
- 모든 가격은 **추정치**로 표기
- 출처, 갱신일, 커버리지, "실가격 차이 가능" 안내 필수
- "결제 단계에서 금액이 달라질 수 있어요" 문구 표시

---

## 5. LLM 행동 원칙

1. **변경안(diff) 먼저**: 바로 추가하지 않고 요약 카드로 제시
2. **설명 없는 추천 금지**: "왜 이 후보가 1등인지" 근거를 반드시 제시
3. **고정모드 자동 변경 금지**: 브랜드 고정 시 더 싼 대안이 있어도 자동 변경 불가
4. **최종 결정권은 사용자**: "결정은 똑장이, 결제는 마트 앱에서"
5. **개인정보 최소 원칙**: 로그는 "품목/선택된 플랜/실행시간/에러" 중심

---

## 6. 데이터 구조 핵심

### BasketItem
```
item_name(정규화), brand(optional), size(optional), quantity, category
```

### Plan (추천 결과)
```
플랜 타입(최저가/가까움/균형), 총액, 매장/몰, 이동시간/거리, 날씨 주의, 품목 커버리지(%)
```

### 정렬 기준
- 1차: 총액(total_cost) 오름차순
- 2차: 커버리지(coverage) 내림차순
- 3차: 이동시간 오름차순

---

## 7. 리스크 방어 원칙

| 리스크 레벨 | 항목 | 방어 전략 |
|---|---|---|
| L1 설계 | 데이터 소스 변경 | Provider 인터페이스 격리 + 캐시 계층 |
| L1 설계 | '최저가' 정의 분쟁 | 총액 vs 시간대비 분리 표시, 기본 정렬은 총액 |
| L2 데이터 | API 쿼터/호출 제한 | 캐시/중복호출 방지/배치 전략 |
| L2 데이터 | 가격 갱신 타이밍 | 갱신일/출처 표기 |
| L3 알고리즘 | 계산량 증가 | 후보 매장 사전 필터 + 상위 K개만 유지 |
| L4 구현 | 좌표/주소 정규화 | 도로명/지번 통합 처리 |
| L4 구현 | 동명이인 상품 | 브랜드/용량 질문으로 확정하는 UX |
